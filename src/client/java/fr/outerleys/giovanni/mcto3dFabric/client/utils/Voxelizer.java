/*
 * McTo3D
 * Copyright (c) 2026 Giovanni Outerleys
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

package fr.outerleys.giovanni.mcto3dFabric.client.utils;

import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.*;

public class Voxelizer {

    public static Map<BlockPos, BlockState> loadAndVoxelize(File objFile, float scale) {
        Map<BlockPos, BlockState> voxels = new HashMap<>();
        List<Vec3d> vertices = new ArrayList<>();
        List<float[]> uvs = new ArrayList<>(); // UV storage (u, v)

        // Texture Management
        BufferedImage textureImg = null;
        try {
            // Find associated PNG file (same name as obj but .png, generated by GlbConverter)
            File textureFile = new File(objFile.getParent(), objFile.getName().replace(".obj", ".png"));
            if (textureFile.exists()) {
                textureImg = ImageIO.read(textureFile);
                System.out.println("Texture loaded for Voxelizer: " + textureFile.getName());
            }
        } catch (Exception e) { e.printStackTrace(); }

        try (BufferedReader reader = new BufferedReader(new FileReader(objFile))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith("#")) continue;
                String[] parts = line.split("\\s+");

                if (parts[0].equals("v")) {
                    vertices.add(new Vec3d(Float.parseFloat(parts[1]), Float.parseFloat(parts[2]), Float.parseFloat(parts[3])));
                }
                else if (parts[0].equals("vt")) {
                    // Read Texture Coordinates
                    uvs.add(new float[]{Float.parseFloat(parts[1]), Float.parseFloat(parts[2])});
                }
                else if (parts[0].equals("f")) {
                    if (parts.length >= 4) {
                        int[] vIdx = new int[3];
                        int[] vtIdx = new int[3];
                        boolean hasUV = false;

                        try {
                            for (int i = 0; i < 3; i++) {
                                String[] faceParts = parts[i + 1].split("/");
                                vIdx[i] = Integer.parseInt(faceParts[0]) - 1;

                                if (faceParts.length > 1 && !faceParts[1].isEmpty()) {
                                    vtIdx[i] = Integer.parseInt(faceParts[1]) - 1;
                                    hasUV = true;
                                }
                            }

                            // Rasterization
                            if (hasUV && !uvs.isEmpty() && textureImg != null) {
                                rasterizeTriangleWithUV(
                                        vertices.get(vIdx[0]), vertices.get(vIdx[1]), vertices.get(vIdx[2]),
                                        uvs.get(vtIdx[0]), uvs.get(vtIdx[1]), uvs.get(vtIdx[2]),
                                        scale, voxels, textureImg
                                );
                            } else {
                                // Fallback without texture (White)
                                rasterizeTriangleSimple(
                                        vertices.get(vIdx[0]), vertices.get(vIdx[1]), vertices.get(vIdx[2]),
                                        scale, voxels
                                );
                            }
                        } catch (Exception e) {}
                    }
                }
            }
        } catch (Exception e) { e.printStackTrace(); }

        return voxels;
    }

    private static void rasterizeTriangleSimple(Vec3d p1, Vec3d p2, Vec3d p3, float scale, Map<BlockPos, BlockState> voxels) {
        // Simple rasterization logic calling internal method with null texture data
        rasterizeInternal(p1, p2, p3, scale, voxels, null, null, null, null);
    }

    private static void rasterizeTriangleWithUV(Vec3d p1, Vec3d p2, Vec3d p3, float[] uv1, float[] uv2, float[] uv3, float scale, Map<BlockPos, BlockState> voxels, BufferedImage img) {
        rasterizeInternal(p1, p2, p3, scale, voxels, uv1, uv2, uv3, img);
    }

    private static void rasterizeInternal(Vec3d p1, Vec3d p2, Vec3d p3, float scale, Map<BlockPos, BlockState> voxels, float[] uv1, float[] uv2, float[] uv3, BufferedImage img) {
        Vec3d v1 = p1.multiply(scale);
        Vec3d v2 = p2.multiply(scale);
        Vec3d v3 = p3.multiply(scale);

        int minX = (int) Math.floor(Math.min(v1.x, Math.min(v2.x, v3.x)));
        int maxX = (int) Math.ceil(Math.max(v1.x, Math.max(v2.x, v3.x)));
        int minY = (int) Math.floor(Math.min(v1.y, Math.min(v2.y, v3.y)));
        int maxY = (int) Math.ceil(Math.max(v1.y, Math.max(v2.y, v3.y)));
        int minZ = (int) Math.floor(Math.min(v1.z, Math.min(v2.z, v3.z)));
        int maxZ = (int) Math.ceil(Math.max(v1.z, Math.max(v2.z, v3.z)));

        BlockPos.Mutable pos = new BlockPos.Mutable();
        Vec3d p;

        for (int x = minX; x <= maxX; x++) {
            for (int y = minY; y <= maxY; y++) {
                for (int z = minZ; z <= maxZ; z++) {
                    p = new Vec3d(x + 0.5, y + 0.5, z + 0.5);

                    // Compute barycentric coordinates (u, v, w) for interpolation
                    double[] bary = computeBarycentric(p, v1, v2, v3);

                    // If inside triangle (weights sum ~ 1 and positive weights)
                    if (isInsideTriangle(bary)) {
                        pos.set(x, y, z);

                        if (img != null && uv1 != null) {
                            // UV Interpolation: UV_pixel = UV1*w1 + UV2*w2 + UV3*w3
                            double texU = uv1[0] * bary[0] + uv2[0] * bary[1] + uv3[0] * bary[2];
                            double texV = uv1[1] * bary[0] + uv2[1] * bary[1] + uv3[1] * bary[2];

                            // Get pixel color
                            int pixelColor = getPixelColor(img, (float)texU, (float)texV);
                            int r = (pixelColor >> 16) & 0xFF;
                            int g = (pixelColor >> 8) & 0xFF;
                            int b = (pixelColor) & 0xFF;

                            voxels.put(pos.toImmutable(), BlockColorMap.getClosestBlock(r, g, b));
                        } else {
                            voxels.put(pos.toImmutable(), Blocks.WHITE_CONCRETE.getDefaultState());
                        }
                    }
                }
            }
        }
    }

    // Maths: Check if point projects inside the triangle
    private static boolean isInsideTriangle(double[] bary) {
        // Tolerance slightly negative to "fill" voxels better (avoid gaps)
        double tolerance = -0.1;
        return bary[0] >= tolerance && bary[1] >= tolerance && bary[2] >= tolerance;
    }

    private static double[] computeBarycentric(Vec3d p, Vec3d a, Vec3d b, Vec3d c) {
        Vec3d v0 = b.subtract(a);
        Vec3d v1 = c.subtract(a);
        Vec3d v2 = p.subtract(a);

        double d00 = v0.dotProduct(v0);
        double d01 = v0.dotProduct(v1);
        double d11 = v1.dotProduct(v1);
        double d20 = v2.dotProduct(v0);
        double d21 = v2.dotProduct(v1);

        double denom = d00 * d11 - d01 * d01;
        if (Math.abs(denom) < 1e-5) return new double[]{-1, -1, -1}; // Degenerate triangle

        double v = (d11 * d20 - d01 * d21) / denom;
        double w = (d00 * d21 - d01 * d20) / denom;
        double u = 1.0 - v - w;

        // Also check distance to plane
        Vec3d normal = v0.crossProduct(v1).normalize();
        double dist = Math.abs(v2.dotProduct(normal));

        if (dist > 0.6) return new double[]{-1, -1, -1}; // Too far from triangle plane

        return new double[]{u, v, w};
    }

    private static int getPixelColor(BufferedImage img, float u, float v) {
        // Texture Wrapping (Repeat)
        u = u - (float)Math.floor(u);
        v = v - (float)Math.floor(v);

        // V Inversion might be needed depending on UV space convention (often yes in 3D)
        // v = 1.0f - v;

        int x = (int) (u * (img.getWidth() - 1));
        int y = (int) ((1.0f - v) * (img.getHeight() - 1)); // Standard Y inversion for images

        if (x < 0) x = 0; if (x >= img.getWidth()) x = img.getWidth() - 1;
        if (y < 0) y = 0; if (y >= img.getHeight()) y = img.getHeight() - 1;

        return img.getRGB(x, y);
    }
}